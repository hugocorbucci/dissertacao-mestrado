%% ------------------------------------------------------------------------- %%
\chapter{Diferenças entre os dois mundos}
\label{cap:diferencas}

O manifesto ágil (apresentado na Caixa \ref{box:manifesto}) é
complementado por uma lista de 12 princípios traduzidos na Caixa
\ref{box:principles}. Esses princípios apresentam guias que norteiam
os métodos ágeis na direção de algumas práticas. Este Capítulo
apresenta uma análise desses princípios sob o ponto de vista de
projetos de software livre com o objetivo de identificar mais algumas
semelhanças mas com destaque para as diferenças entre as comunidades.

\begin{caixa}[htb]
  \begin{minipage}{\linewidth}
    \centering Seguimos esses princípios:

    \begin{itemize}
    \item Nossa maior prioridade é satisfazer o cliente através da
      entrega contínua e adiantada de software com valor agregado;
    \item Mudanças nos requisitos são bem-vindas, mesmo tardiamente no
      desenvolvimento.  Processos ágeis tiram vantagem das mudanças
      visando vantagem competitiva para o cliente;
    \item Entregar frequentemente software funcionando, de poucas
      semanas a poucos meses, com preferência à menor escala de tempo;
    \item Pessoas de negócio e desenvolvedores devem trabalhar
      diariamente em conjunto por todo o projeto;
    \item Construa projetos em torno de indivíduos motivados.  Dê a
      eles o ambiente e o suporte necessário e confie neles para fazer
      o trabalho;
    \item O método mais eficiente e eficaz de transmitir informações
      para e entre uma equipe de desenvolvimento é através de conversa
      face a face;
    \item Software funcionando é a medida primária de progresso;
    \item Os processos ágeis promovem desenvolvimento sustentável. Os
      patrocinadores, desenvolvedores e usuários devem ser capazes de
      manter um ritmo constante indefinidamente;
    \item Contínua atenção à excelência técnica e bom \textit{design}
      aumenta a agilidade;
    \item Simplicidade -- a arte de maximizar a quantidade de trabalho
      não realizado -- é essencial;
    \item As melhores arquiteturas, requisitos e \textit{designs}
      emergem de equipes auto-organizáveis;
    \item Em intervalos regulares, a equipe reflete sobre como se
      tornar mais eficaz e então refina e ajusta seu comportamento de
      acordo.
    \end{itemize}
  \end{minipage}
  \caption{Os 12 princípios do manifesto ágil}
  \label{box:principles}
\end{caixa}

A Seção \ref{sec:principles} apresenta a relação de princípios ágeis e
sua ligação com software livre para identificar os pontos principais
de diferença entre os movimentos. Em seguida, a Seção
\ref{sec:foss-over-agile} apresenta um pequeno resumo de um
\textit{workshop}\footnote{\url{http://submissions.agile2008.org/node/376}
  - Acessado em 16/03/2009} conduzido por Mary Poppendieck com
Christian Reis na Agile 2008. O \textit{workshop}, intitulado
\textit{``Open Source Meets Agile - What can each teach the other?''}
tinha como objetivo discutir práticas de sucesso em um projeto de
software livre que não eram encontradas em métodos ágeis. Desta forma,
os participantes poderiam compreender alguns princípios essenciais que
se aplicam a projetos de software livre e poderiam propor melhorias
aos atuais métodos ágeis.

Contrastando com este trabalho, a Seção \ref{sec:agile-improve-os}
apresenta as deficiências dos métodos ágeis mais conhecidos atualmente
no que diz respeito ao contexto de software livre. A Seção também
aborda como a criação dessa solução poderia ajudar tanto projetos de
software livre quanto a comunidade de métodos ágeis.

\section{Princípios ágeis sob a ótica livre}
\label{sec:principles}

A lista de princípios ágeis apresenta alguns pontos de semelhança e
outros de diferença com software livre. As próximas Seções discutem
cada um dos princípios e seu uso em projetos de software livre.

\subsection[Satisfação do cliente]{Nossa maior prioridade é satisfazer
  o cliente através da entrega contínua e adiantada de software com
  valor agregado}

Esse princípio traduz para ações o valor de resposta a mudanças. Como
comentado no Capítulo \ref{cap:semelhancas}, projetos livres tem a
obrigação de atender aos pedidos de seus usuários caso contrário são
abandonados. Tem se tornado frequentes os projetos livres em que
existe uma periodicidade fixa para lançamento de novas versões como o
Eclipse\footnote{\url{http://www.eclipse.org/} -- Último acesso em
  21/04/2010} (que tem novas versões estáveis a cada ano e novas
versões instáveis a cada dois meses), a distribuição Linux
Ubuntu\footnote{\url{http://www.ubuntu.com} -- Último acesso em
  21/04/2010} (com versões estáveis a cada seis meses e versões
instáveis a cada dois meses) e o
OpenOffice\footnote{\url{http://www.openoffice.org} -- Último acesso
  em 21/04/2010} (cujas versões estáveis tem o objetivo de ser
lançadas a cada seis a oito meses e contar com três instáveis nesse
intervalo).

Esse ritmo permite obter feedback da comunidade sobre o andamento do
desenvolvimento. Para saber o que traz valor ao cliente, alguns
projetos também tem um sistema de rastreamento de problemas nos quais
os usuários podem ``votar'' nas funcionalidades mais importantes para
a próxima versão. O Bugzilla\footnote{\url{http://www.bugzilla.org} --
  Último acesso em 21/04/2010} é uma das ferramentas que permite esse
tipo de participação entre outras como
JIRA\footnote{\url{http://www.atlassian.com/software/jira/} -- Último
  acesso em 21/04/2010} e GitHub\footnote{\url{http://www.github.com}
  -- Último acesso em 21/04/2010}.

Dessa forma, muitos projetos de software livre abraçam esse princípio
e o incorporam em seus processos de desenvolvimento para poder atender
a sua comunidade.

\subsection[Aceitar as mudanças]{Mudanças nos requisitos são
  bem-vindas, mesmo tardiamente no desenvolvimento.  Processos ágeis
  tiram vantagem das mudanças visando vantagem competitiva para o
  cliente}

Nesse aspecto, projetos livres costumam adotar uma postura
extremamente ágil. Por conta da característica distribuída e
\textit{ad hoc} do software livre, é muito raro existir um momento de
coleta de requisitos pré-determinado. A coleta costuma acontecer de
forma contínua conforme usuários dos projetos enviam relatos de erros
e pedidos de funcionalidades ou conforme discussões acontecem nas
listas de correio eletrônico dos projetos.

Dessa forma, a questão de aceitar mudanças nos requisitos ``tarde'' no
desenvolvimento fica um pouco estranha. O único momento que pode ser
classificado como ``tarde'' num projeto com coleta contínua de
requisitos é uma vez que o requisito já estiver implementado. Mas a
partir desse momento, mudanças no funcionamento passam a ser
descrições de erros (comportamento não esperado ou não desejado do
sistema).

Para a segunda parte do princípio afirma que essa resposta à mudança
deve se dar de forma a garantir um diferencial competitivo ao cliente,
isto é, as mudanças incorporadas devem ir na direção que atrairá mais
usuários. Em software livre, é muito difícil descobrir a curto ou
médio prazo o impacto de uma nova funcionalidade na base de usuários
já que a adoção e difusão dos projetos é relativamente lenta e pouco
controlada. Mas a longo prazo, apenas os projetos que conseguirem se
destacar permanecem.

\subsection[Entregas frequentes]{Entregar frequentemente software
  funcionando, de poucas semanas a poucos meses, com preferência à
  menor escala de tempo}

% TODO mais análises

O freshmeat\footnote{\url{http://freshmeat.net/} -- Último acesso em
  23/04/2010} é um dos maiores site de notícias sobre novas versões de
projetos livres. O site está em atividade desde meados de 1990 e ainda
mantem seu histórico desde Fevereiro de 2001. Desta data até
23/04/2010, foram 205725 novas versões que formam uma média de 61.08
novas versões por dia.

Até 23/04/2010, eram 22227 projetos livres repertoriados e
controlados. Esses dados apontam uma média de 9.25 novas versões por
projeto ao longo de 3368 dias (9 anos e alguns meses).
Aproximadamente uma nova versão por ano por projeto.

Desse ponto de vista, parece que os projetos livres não seguem muito
esse princípio ágil. Mas deve-se também considerar que entre todos os
projetos listados, alguns podem ter sido abandonados ou simplesmente
não avisaram o site de suas novas versões. Portanto é provável que
essa média não reflita a realidade para projetos de software livre
ativos.

Além disso, vale notar que a escala de tempo para projetos livres
costuma ser um pouco maior do que em projetos proprietários que contam
com a dedicação em tempo integral dos membros da equipe. Desse ponto
de vista, algumas semanas de um projeto com dedicação integral pode
ser considerado equivalente a alguns meses num projeto baseado em
voluntários.

De toda forma, esses resultados são indícios de que projetos livres
não seguem o princípios de entregar novas versões funcionais em
escalas de tempo pequenas. Esse é um ponto de possível melhora para
esses projetos.

\subsection[Trabalhar com pessoas de negócio]{Pessoas de negócio e
  desenvolvedores devem trabalhar diariamente em conjunto por todo o
  projeto}

Este é outro princípio em que o contexto comum de projetos livres
torna um pouco estranha a afirmação. Como Raymond diz: ``Todo bom
projeto de software começa com um desenvolvedor resolvendo um incômodo
pessoal'' \cite{Raymond1999}. Nesse caso, o especialista do negócio é
o próprio desenvolvedor o que faz com que seja impossível um trabalhar
sem o outro.

Desta forma, parece que qualquer projeto livre, para que evolua,
precisa abraçar esse princípio e garantir que sempre há algum
desenvolvedor envolvido que entenda o negócio que o projeto se propõe
a simplificar.

\subsection[Trabalhe com indivíduos motivados]{ Construa projetos em
  torno de indivíduos motivados.  Dê a eles o ambiente e o suporte
  necessário e confie neles para fazer o trabalho}

Para esse princípio parece mais justa a inversão de análise. Software
livre tem como premissa o envolvimento voluntário e, portanto,
motivado. A partir dessa motivação, os indivíduos reunem-se na
Internet (ambiente necessário) e começam a evoluir o projeto.

Não existe sequer a dúvida com relação à confiança ou mesmo a
necessidade de um fator externo de suporte. Os projetos livres evoluem
encima da possibilidade de se auto-gerenciarem e evoluirem
independentemente de fatores externos. A tolerância a falhas no
eco-sistema livre faz com que projetos que encontram dificuldades
demais na sua evolução falhem e, se o problema for muito importante,
serão atacados novamente no futuro até que seja viável chegar a algum
resultado prático.

\subsection[Conversa face a face]{O método mais eficiente e eficaz de
  transmitir informações para e entre uma equipe de desenvolvimento é
  através de conversa face a face}

Este é o princípio no qual está mais clara a separação entre software
livre e métodos ágeis. Pela natureza distribuída já discutida de
projetos livres, é praticamente impossível reunir os colaboradores de
um projeto num mesmo espaço físico. Por conta disso, o uso da conversa
face a face em projetos de software livre é praticamente impossível.

Como os resultados do questionário apresentado na Seção
\ref{sec:resp-floss}, o canal de comunicação mais usado e melhor
avaliado em projetos de software livre são listas de correio
eletrônico seguidos de canais IRC. Ambos são bem distantes de
conversas face a face. O primeiro não conta sequer com respostas
síncronas que é o único benefício apresentado no segundo. Com relação
a conversas face a face, ambos canais perdem a entonação da voz, as
expressões faciais, gesticulações além do contato visual.

Esse uso é tão difundido e aceito na comunidade de software livre que,
como apresentado na Seção \ref{sec:resp-floss}, canais IRC são até
melhor avaliados em termos de eficácia e eficiência do que as
conversas face a face pelos contribuidores. Percebe-se também que
outros canais mais próximos de conversas face a face tem um uso muito
raro o que mostra também uma falta de vontade de mudar a situação
atual.

Por tanto, pode-se dizer que há uma diferença real de valores nesse
aspecto. Métodos ágeis abrem mão da rastreabilidade das conversas em
prol de uma maior interação enquanto comunidades de software livre
favorecem esse histórico e essa rastreabilidade e consideram que os
canais menos fortes são suficientemente eficientes.

\subsection[Software funcionando]{Software funcionando é a medida
  primária de progresso}

Neste ponto, percebe-se talvez a maior ligação entre as duas
comunidades.

Projetos de software livre costumam ser avaliados de acordo com o
tamanho de sua comunidade e com relação à sua adoção. Desta forma, o
progresso de um projeto livre pode ser medido pela sua capacidade de
agregar uma comunidade importante e de ser adotado por muitos
usuários.

No entanto, é impossível ser adotado por usuários caso não exista um
programa em funcionamento. Além disso, de acordo com Riehle
\cite{Riehle2007}, as pessoas se envolvem com um projeto livre porque
este projeto as ajuda a resolverem seus problemas. Dito isso, não
basta ter algo em funcionamento, o programa precisa resolver os
problemas de seus usuários para atrair sua atenção e torná-los
colaboradores.

Sendo assim, parece razoável afirmar que o progresso de um projeto
livre só pode se dar com a liberação de software funcionando. Ou seja,
o progresso de um projeto livre pode ser medido pela sua capacidade de
entregar software funcionando.

\subsection[Ritmo sustentável]{Os processos ágeis promovem
  desenvolvimento sustentável. Os patrocinadores, desenvolvedores e
  usuários devem ser capazes de manter um ritmo constante
  indefinidamente}

No caso de projetos livres, o ritmo é ditado pelo envolvimento dos
voluntários de acordo com suas possibilidades. Dada a ausência de uma
entidade controladora da dedicação de cada parte, o ritmo de
comunidades de software livre é variado.

A proposta mais recente para atingir algo nesse sentido nas
comunidades livres é da ideia de lançamentos cadenciados. O Firefox e
o Ubuntu tem procurado lançar novas versões em intervalos de tempo
fixo e com escopo aberto. Isso significa que uma nova versão será
lançada numa data pré-determinada com as funcionalidades que estiverem
prontas e testadas.  Dessa forma, tira-se a pressão para conseguir
terminar determinado trabalho até uma certa data.

Infelizmente essa medida não garante que a equipe consiga manter um
ritmo constante.

% TODO Melhorar

\subsection[Excelência técnica]{Contínua atenção à excelência técnica e bom
  \textit{design} aumenta a agilidade}

Por construção, o movimento de software livre envolve pessoas
apaixonadas por desenvolvimento. Nesse aspecto, projetos livres tendem
a utilizar todo tipo de tecnologia.  Dia 18 de Agosto de 2010, os 10
projetos mais baixados do SourceForge.net reuniam 6 linguagens de
programação diferentes (C, C++, Python, Javascript, Delphi e Perl).

Por outro lado, o cuidado com design e refatorações não é uma das
características fortes das comunidades livres. \textbf{Precisaria
  coletar uns dados sobre projetos livres}.

\subsection[Simplicidade é essencial]{Simplicidade -- a arte de
  maximizar a quantidade de trabalho não realizado -- é essencial}

Software livre se apoia no princípio da quantidade para obter
qualidade. Isso significa que muitos projetos são criados, evoluidos e
mantidos por um tempo mas abandonados em seguida. Nesse sentido,
existe MUITO trabalho realizado que é pouco aproveitado.

\textbf{Pegar dados do Sourceforge para mostrar que a grande maioria
  dos projetos praticamente nunca foram usados.}

\subsection[Equipes auto-organizáveis]{As melhores arquiteturas,
  requisitos e \textit{designs} emergem de equipes auto-organizáveis}

A teoria com relação a esse princípio é a mesma em ambas
comunidades. Projetos livres emergem da vontade de programadores que
se auto-organizam para desenvolver um programa.

No entanto, é fácil argumentar que a arquitetura e os \textit{designs}
encontrados nos projetos livres raramente são consideradas as
melhores.

No que diz respeito aos requisitos, de acordo com Eric Raymond,
projetos livres surgem de problemas enfrentados pelos seus próprios
desenvolvedores. Neste caso, os requisitos vem dos próprios
desenvolvedores o que simplifica amplamente o problema de
entendimento.

\subsection[Refletir regularmente]{Em intervalos regulares, a equipe
  reflete sobre como se tornar mais eficaz e então refina e ajusta seu
  comportamento de acordo}

Aqui está uma das diferenças mais claras entre métodos ágeis e
projetos livres. A capacidade e costume de juntar a equipe para pensar
sobre o processo de desenvolvimento dificilmente é possível
considerando que o modelo de desenvolvimento é assíncrono, distribuído
e voluntário.

\section{Princípios do Software Livre interessantes em Métodos Ágeis}
\label{sec:foss-over-agile}

Reis é um desenvolvedor Brasileiro de software livre que trabalha para
a Canonical Inc. no desenvolvimento do LaunchPad
\footnote{\url{http://launchpad.net/} - Último acesso 24/04/2009}, o
projeto de gerenciamento de software para a distribuição Linux
Ubuntu. O \emph{workshop} teve início com a apresentação de Reis sobre
como o LaunchPad é desenvolvido. Três pontos essenciais foram
levantados durante a discussão que deu sequência à apresentação. O
primeiro (Subseção \ref{subsec:commiter}) descreve e discute o papel
de \emph{commiter}.  O segundo (Subseção \ref{subsec:publicity})
apresenta os benefícios de seguir um processo de desenvolvimento que
seja público e transparente.  Por fim, o último (Subseção
\ref{subsec:crossrev}) aborda o sistema de revisão cruzada dos
sistemas que é usado para garantir a comunicação e a clareza do
código.

\subsection{O papel do \emph{Commiter}}
\label{subsec:commiter}

Parte do valor que foi identificado no software livre foi o papel do
\emph{commiter}. Como esse papel tem uma relação relativamente
complicada com métodos ágeis, essa subseção será divida em quatro
partes. A primeira descreve o que é um \emph{commiter}. A segunda
apresenta como esse papel é distribuído em métodos ágeis. A terceira
aborda as diferenças e semelhanças entre a revisão realizada durante a
programação em pares e a revisão feita pelo \emph{commiter}. Por fim,
a quarta apresenta as sugestões de adaptação desse papel em métodos
ágeis.

\subsubsection{O que é um \emph{commiter}}

Um \emph{commiter} é uma pessoa que tem direito de adicionar,
modificar e remover código fonte ao ``ramo''\footnote{Um ramo
  (\emph{branch}) de um repositório é uma ramificação da estrutura de
  diretórios que guarda os arquivos} principal do repositório de
controle de versões. O ``ramo'' principal é a parte do código que será
empacotada para formar uma nova versão do programa. Aos olhos da
comunidade do software, o \emph{commiter} é uma pessoa confiável muito
qualificada para avaliar a qualidade do código fonte. Este é o meio
encontrado pelas comunidades de software livre para revisar a grande
maioria do código fonte de forma a reduzir a quantidade de erros e
melhorar a clareza do código.

A maioria dos projetos de software livre tem um grupo muito pequeno de
\emph{commiters}. Frequentemente o líder do projeto é o único
\emph{commiter} e todos os \emph{patches} devem passar por sua
aprovação. De acordo com Riehle \cite{Riehle2007}, existem três níveis
na hierarquia tradicional de um projeto de software livre.
\begin{itemize}
\item O primeiro nível é o de usuário.

  Usuários têm o direito de usar o programa, relatar problemas e pedir
  funcionalidades.
\item O segundo nível é o de contribuidor.

  A promoção entre o primeiro e o segundo nível é implícita. Ela
  acontece quando um \emph{commiter} aceita os \emph{patches} do
  usuário e os envia ao repositório de código no ``ramo''
  principal. Normalmente, ninguém sabe dessa promoção, com exceção do
  \emph{commiter} e do contribuidor.
\item O terceiro papel é o de \emph{commiter}.

  Neste nível, a transição é explícita. Contribuidores e
  \emph{commiters} demonstram apoio a uma determinada pessoa e
  reconhecem publicamente a qualidade geral de seu trabalho. Por isso,
  atingir o nível de \emph{commiter} é um feito valioso que significa
  que essa pessoa produz código de ótima qualidade e está realmente
  envolvida com o desenvolvimento do projeto.
\end{itemize}

\subsubsection{O papel do \emph{commiter} em métodos ágeis}

Métodos ágeis delegam o papel do \emph{commiter} para cada um dos
desenvolvedores da equipe. No \emph{workshop} sugeriram que alguma
forma de controle no ``ramo'' principal de um projeto ágil poderia
melhorar ainda mais a simplicidade do código fonte do aplicativo de
produção.

Na maioria dos métodos ágeis, uma equipe deveria ter um líder (um
\emph{Scrum Master} em Scrum, um \emph{coach} em XP, etc...)  que é
mais experiente naquele método ágil que o resto da equipe. O líder da
equipe é responsável por lembrar a equipe de se ater às práticas
escolhidas. Ele também deve ajudar a equipe a resolver os problemas
encontrados e idealmente, transformar todos os membros da equipe em
possíveis líderes de forma a tornar-se ``inútil''.

Para cumprir essa função, o líder não precisa obrigatoriamente ter
conhecimentos técnicos apurados. No entanto, uma equipe de
desenvolvimento costumeiramente precisa de ajuda do ponto de vista
técnico em alguma parte de seu trabalho. Alguns dos problemas
levantados por uma equipe podem ser causados por decisões ou por
dificuldades técnicas. Neste caso, se o líder não tiver conhecimento
técnico, ele pode encontrar dificuldades para cumprir sua função. Para
resolver este problema, é comum que o líder tenha a ajuda de um
consultor técnico que pode ser um membro da equipe ou uma pessoa de
fora.

Se este consultor técnico for um membro da equipe, ele tem,
indiretamente, a responsabilidade de fazer com que a equipe mantenha
uma boa qualidade de código. Pensando assim, o responsável técnico tem
a função de \emph{commiter} do projeto mas realiza seu trabalho
lembrando aos programadores de que seu código deve estar sempre
legível, claro e com testes passando.

\subsubsection{Semelhanças e diferenças da revisão}

O papel ativo de revisor que o \emph{commiter} tem em projetos de
software livre é encontrado no copiloto de uma dupla de programação em
pares. Note, no entanto, que a revisão de código realizada durante a
programação em pares tem como objetivo principal a redução de erros e
não é obrigatoriamente eficiente no aumento da clareza do código. Isso
se dá porque, quando um par trabalha em uma tarefa, ambas pessoas
mergulham em um determinado trecho de código e criam juntas uma linha
de pensamento. Para ambos os envolvidos, o tal trecho de código pode
ser muito claro graças ao contexto e à linha de pensamento que eles
criaram. Mas, para alguém que não acompanhou essa linha, o código pode
ser muito complexo se ele não deixar indícios do raciocínio que deve
ser seguido.

A revisão feita pelo \emph{commiter} dificilmente será mais eficiente
que a do par para reduzir a quantidade de erros já que o revisor
costuma ter menos tempo para pensar sobre o problema e entender os
possíveis casos envolvidos. Enquanto o par que trabalhou no código
teve exatamente este objetivo. No entanto, o \emph{commiter} traz um
olhar fresco ao código que é muito mais semelhante ao olhar de um
desenvolvedor qualquer no futuro. Deste ponto de vista, é mais
provável que o revisor questione o código de forma semelhante àquela
que outra pessoa no futuro faria. Sendo assim, o \emph{commiter} pode
evitar os principais problemas relacionados à clareza do código
produzido.

De qualquer forma, o trabalho de revisão tem duas consequências
diretas e evidentes. A primeira é de que o tempo necessário para que
uma mudança seja incorporada ao ``ramo'' principal do código aumenta
consideravelmente já que, tipicamente, são necessárias algumas
conversas entre o revisor e os autores do código. A segunda é que o
trabalho do revisor, se ele for único, é considerável já que ele deve
ler todo código que deve ir para o ``ramo'' principal, tentar
entendê-lo e expressar suas dúvidas aos autores.

\subsubsection{Sugestões para adaptar o papel aos métodos ágeis}

Considerando os pontos apresentados no fim da seção anterior, dar o
papel de \emph{commiter} ao consultor técnico de uma equipe ágil
significaria criar um gargalo de incorporação de código. A Teoria das
Restrições \cite{goldratt84} afirma que deve-se eliminar os gargalos
para maximizar a produtividade de uma equipe.

Sendo assim, a proposta é manter um pequeno conjunto de
desenvolvedores da equipe como \emph{commiters} e fazer o papel
circular entre os membros da equipe. Ao trocar os membros do conjunto
de \emph{commiters}, permite-se uma maior distribuição do conhecimento
e reduz-se a aparente concentração de poder desse papel. A troca
também permite que aqueles que foram \emph{commiters} possam, por sua
vez, serem autores de alguns trechos de código que passarão por
avaliação de outros. Desta forma, toda a equipe passa a entender o
valor de cada um dos papéis e entende melhor como escrever código que
seja claro para um revisor.

\subsection{Resultados públicos}
\label{subsec:publicity}

Outro ponto importante da discussão foi a divulgação pública de todos
os resultados relacionados ao projeto. De acordo com Reis, programas
proprietários também podem se beneficiar de um sistema de rastreamento
de erros público e da publicação dos resultados dos testes
automatizados. Para abraçar os benefícios dessas práticas é necessário
expor alguns detalhes de código. Disponibilizar esses resultados
publicamente encoraja os usuários a participar do processo de
desenvolvimento já que eles entendem como e quando o programa é
melhorado.

Em métodos ágeis, o resultado dos testes e a lista fornecida pelo
sistema de rastreamento de erros são informações muito importantes
para a equipe de desenvolvimento. Apesar disso, nenhum métodos afirma
explicitamente que o cliente e os usuários deveriam estar em contato
direto com essas ferramentas.

É senso comum em métodos ágeis que o cliente deveria ser parte da
equipe de desenvolvimento. Como a equipe deve estar sempre em contato
com essas ferramentas, pode-se interpretar que o cliente deveria usar
a ferramenta de forma semelhante ao resto da equipe. Infelizmente, a
maioria das ferramentas usadas são muito rudimentares do ponto de
vista de um cliente não técnico já que poucas delas se preocupam em
atribuir um significado de negócios aos resultados.

Algumas iniciativas\footnote{RSpec - \url{http://rspec.info/} - Último
  acesso em 30/09/2008}$^{, }$\footnote{JBehave -
  \url{http://jbehave.org/} - Último acesso em 30/09/2008}
relacionadas aos testes já existem ligadas ao movimento de
Desenvolvimento Dirigido pelo Comportamento (\emph{BDD - Behaviour
  Driven Development}) \cite{North2006} para produzir melhores
relatórios. Já no ponto de vista dos sistema de rastreamento de erros,
a evolução não aconteceu pontualmente mas as ferramentas mais recentes
tendem a apresentar uma interface com menos detalhes técnicos para
alguns usuários (clientes).

Mas a divulgação pública de informações relacionadas ao projeto não se
restringe aos erros ou aos testes. Nas comunidades de software livre,
as discussões entre os membros do projeto e até as discussões com
pessoas de fora do projeto sempre são guardadas no histórico da lista
de correio eletrônico usada. Discussões fora dessa lista são
fortemente desencorajadas já que elas impedem outras pessoas de
contribuir com comentários e ideias. Os históricos das listas ajudam a
construir uma documentação para futuros usuários assim como criar um
rápido sistema de \emph{feedback} para novatos.

Além disso, manter o histórico da lista também inibe atitudes
desrespeitosas já que todas as discussões são salvas e guardadas para
acesso futuro. Desta forma, os participantes costumam manter o
respeito (que é importantíssimo para o sucesso de qualquer projeto)
entre eles e com novatos. Aqui percebe-se mais uma forte ligação com
métodos ágeis. Respeito é um dos cinco valores da Programação Extrema
\cite{XP02}.

A rastreabilidade é um dos pontos fracos dos métodos ágeis. A maioria
dos métodos sugere que o projeto do software (\emph{design}) evolua
com o tempo conforme as necessidades. Essa evolução deveria fluir
naturalmente dos quadros brancos ou \emph{flip charts}. O problema com
essa abordagem é que quadro brancos são apagados e \emph{flip charts}
são reciclados.  Mesmo quando estes são guardados de alguma forma
(fotos, transcrições ou até mesmo no código), as discussões que
levaram à solução são perdidas.

A fala é uma forma muito eficiente de comunicação mas também muito
efêmera. Mesmo quando uma conversa é gravada, é difícil buscar
informações sobre algum trecho da discussão. Correios eletrônicos são
muito menos eficientes para a comunicação mas têm um grande ganho na
facilidade de busca. Num curto prazo, é evidente que a conversa é
muito mais eficiente para transmitir ideias que a escrita,
especialmente em equipes pequenas. No entanto, num médio ou longo
prazo, os ganhos da comunicação escrita podem superar (como eles o
fazem em projetos livres) as perdas.

\subsection{Revisão cruzada}
\label{subsec:crossrev}

O terceiro ponto que Reis apresentou foi bem específico ao
LaunchPad. Como o LaunchPad é uma plataforma usada por outras equipes
para que elas desenvolvam seus próprios projetos, quando há uma
mudança na Interface de Programação da Aplicação (\emph{API -
  Application Programming Interface}), um membro de uma equipe externa
que usa o programa (preferenciamente uma pessoa diferente a cada vez)
deve revisar a mudança da interface e os motivos que levaram a
ela. Essa mudança não pode ser enviada ao ``ramo'' principal do
repositório a não ser que o revisor externo a aprove. Essa prática é
conhecida como revisão cruzada das mudanças de API ou, simplesmente,
uma revisão cruzada.

Essa prática resolve alguns problemas de uma só vez. O papel do
\emph{commiter} resolve o problema da revisão de código que os métodos
ágeis atacam com a programação em pares. A revisão cruzada garante que
a mudança da interface é aprovada pelos usuários assim como os
desenvolvedores.

Ela também garante uma melhora considerável sobre aquela API já que a
conversa entre o desenvolvedor do projeto e o usuário é arquivada pela
lista de correio eletrônico. Desta forma, futuros usuários ou mesmo
outros usuários atuais podem ler e entender porque a API mudou e como
usá-la quando for necessário. Também fica mais fácil realizar mudanças
no futuro e simplificações já que fica claro o que aquela API está
querendo permitir e se aquilo ainda faz sentido nas novas versões.

Por fim, a revisão cruzada também ajuda a envolver o cliente nas
decisões de arquitetura da solução e garante que ele está de acordo
com as mudança realizada. Com isso, é mais fácil identificar um
possível problema de requisitos e corrigi-lo antes que eles sejam
implementados na base principal de código. Obviamente, esta prática só
pode se aplicar até um certo nível quando o usuário não tem
conhecimento técnico. Uma revisão externa pode ajudar a garantir a
clareza da API e a documentar as mudanças mas ela não vai identificar
problemas de requisitos se o revisor não for um cliente ou usuário.

\section{Contribuições de Métodos Ágeis no Software Livre}
\label{sec:agile-improve-os}

A maioria dos problemas apontados até agora são relacionados a
dificuldades de comunicação causados pela quantidade de pessoas
envolvidas no projeto, separação física e sua diversidade de
conhecimentos e culturas. Apesar desses fatores serem levados ao
extremo em projetos de software livre, equipes de métodos ágeis
distribuídas encontram alguns dos mesmos problemas
\cite{Sutherland2007,Maurer2002}.

Como Beck sugere \cite{Beck2008}, ferramentas podem melhorar a adoção
e o uso de práticas ágeis e, dessa forma, melhorar o processo de
desenvolvimento. Uma quantidade considerável de trabalho já foi
realizado na questão de ferramentas da programação em pares
distribuída\footnote{\url{http://sf.net/projects/xpairtise/} - Último
  acesso: 02/10/2008}$^{,}$
\footnote{\url{https://www.inf.fu-berlin.de/w/SE/DPP} - Último acesso:
  26/09/2009}$^{,}$ \footnote{\url{http://sangam.sourceforge.net/} -
  Último acesso: 26/09/2009} e estudos a respeito \cite{Nagappan2003}
mas pouco tem sido produzido para apoiar outras práticas. Como o
problema está relacionado à comunicação, algumas práticas de métodos
ágeis são relevantes. As próximas subseções vão apresentar essas
práticas e as ferramentas sugeridas para facilitar a adoção de métodos
ágeis na comunidade de software livre.

\subsection{Ambiente informativo}
\label{subsec:inform-worksp}

Essa prática sugere que uma equipe de métodos ágeis deveria trabalhar
num ambiente que provê informações relacionadas ao trabalho. Beck
\cite{XP01} atribui um papel específico, o de acompanhador
(\emph{tracker}), para uma pessoa (ou algumas pessoas) que deve manter
essa informação disponível e atualizada para a equipe. Com equipes
concentradas em um mesmo local físico, o acompanhador normalmente
coleta métricas \cite{Sato2007} automaticamente e seleciona algumas
delas para apresentá-las no ambiente. A maioria das métricas objetivas
são relacionadas ao código fonte enquanto as métricas subjetivas
costumam depender da opinião dos membros da equipe.

A coleta destes dados não é uma tarefa árdua mas normalmente consome
um tempo considerável e não agrega um benefício imediato ao projeto. É
provalvemente esse o motivo para a falta de métricas ou dados
atualizados em páginas de projeto de software livre. Uma ferramenta
que poderia melhorar esse cenários seria um sistema baseado em
\emph{plug ins} com um conjunto inicial de métricas e uma forma de
criar e apresentar novas métricas. Essas ferramentas deveriam estar
disponíveis em incubadoras de software livre de forma a permitir que
os projetos possam facilmente ligar seus repositórios e páginas à
ferramenta.

\subsection{Histórias}
\label{subsec:stories}

Com relação ao sistema de planejamento, XP sugere que os requisitos
deveriam ser coletados em cartões de histórias. O objetivo disto é
reduzir a quantidade de esforço necessário para descobrir qual é o
próximo passo a ser tomado e tornar fácil modificar essas prioridades
ao longo do tempo. Projetos de software livre normalmente guardam seus
requisitos em sistemas de rastreamento de erros. Quando se identifica
a falta de uma funcionalidade, cadastra-se um erro que deveria ser
corrigido e as discussões e sugestões de mudanças são enviadas para
aquele ``erro''. O problema com essa abordagem é que mudar a
prioridade desses ``erros'' e organizar um planejamento consome muito
tempo e se baseia em fatos que podem mudar com o tempo (tal como
``essa versão deveria resolver erros com prioridade acima de
8''). Também é muito difícil obter uma visão geral dos requisitos.

Descobrir as principais prioridades para a equipe rapidamente e ser
capaz de mudar essas prioridades de acordo com o \emph{feedback} é uma
das chaves para desenvolver software funcional. Para poder atingir
esse objetivo, uma ferramenta deveria ser desenvolvida para permitir
que erros sejam vistos como objetos móveis num quadro de planejamento
de versão. Para permitir que a comunidade envolvida possa colaborar
com seu conhecimento, a ferramenta deveria apresentar a prioridade do
erro assim como seu conteúdo de uma forma similar ao dos artigos da
Wikipedia \cite{Surowiecki2004,Tapscott2006,Benkler2006}.

\subsection{Retrospectiva}
\label{subsec:retrospect}

Essa prática sugere que a equipe deveria se juntar num ambiente físico
periodicamente para discutir o andamento do projeto. Existem dois
problemas nessa prática em equipes de software livre. O primeiro é de
que todos os membros da equipe devem estar presentes ao mesmo tempo no
mesmo lugar. O segundo é fazer com que a equipe interaja de forma
coletiva para apontar os problemas e as soluções que surgiram durante
o período avaliado. A forma mais comum para ajudar os participantes a
realizar esse trabalho é apresentar uma linha temporal e pedir para
que eles façam anotações sobre os eventos que ocorreram nesse
período. Isso os ajuda a relembrar os acontecimentos e entender porque
as coisas aconteceram da forma que aconteceram.

Quando a equipe está reunida em um único local físico, basta juntar a
equipe numa sala de reunião com uma linha do tempo grande na parede e
distribuir papéis coloridos que eles possam colar na linha. A sugestão
para equipes de software livre é desenvolver uma ferramenta baseada na
Internet para permitir que essas anotações sejam feitas numa linha do
tempo virtual associada ao código fonte. Dessa forma, mensagens de
integração de código poderiam conter a anotação que seria
automaticamente exibida na linha do tempo. Além disso, a equipe
poderia anotar a linha do tempo de forma assíncrona para permitir
comentários posteriores. O líder da equipe poderia ocasionalmente
gerar um relatório para todos os membros da equipe além de exibir a
linha do tempo no ambiente informativo.

\subsection{Papo em pé}
\label{subsec:stand-up}

Papos em pé, originalmente sugeridos em Scrum, pedem que toda a equipe
se junte e cada membro explique rapidamente o que ele tem feito e
pretende fazer a seguir. Essa prática compartilha dos mesmos problemas
da retrospectiva. Ela envolve reunir a equipe ao mesmo tempo. Muitos
projetos de software livre usam canais de IRC (\emph{Internet Relay
  Chat}) para resolverem parcialmente esse problema e para centralizar
as discussões durante o desenvolvimento. Apesar disso não garantir que
todos saibam o que cada um está fazendo, ajuda a sincronizar o
trabalho.

Para garantir que os membros obtenham a informação necessária, a
sugestão é que a comunicação que acontece nesses canais IRC seja salva
e exibida aos usuários que acabam de se conectar. Também deveria ser
possível permitir que os usuários deixem anotações a partir desse
canal para o sistema de rastreamento de erros assim como mensagens
para outros contribuidores. No canal IRC, esse tipo de solução
normalmente é implementada por um robô que deveria estar ligado à
incubadora do projeto que contém as ferramentas previamente sugeridas.
